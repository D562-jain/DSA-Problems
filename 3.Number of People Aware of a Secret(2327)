/*Thought proces
People who learned the secret on days=[n-forget+1, n-delay] will contribute to nth day
=>Similar smaller sub-problem{Recursion+Memoisation+Bottom up}=DP

Ist Method=T.C=O(n*(forget-delay)), S.C=O(N)
Step-1: Recursion-Return no. of people know the secret on day
int solve(day){
    //base case
    if(day==1) return 1;//Only one person know secret
    result=0;
    for(d=day-forget+1; d<day-delay; d++){
        result=(result+solve(d))%M;
    }
    return result
}
total=0
for(day=n-forget+1; day<=n; day++){
    total=(total+solve(day))%M;
}
return total

class Solution {
public:
    int M=1e9+7;
    //this will return total number of people who know secret on day "day"
    int solve(int day, int delay, int forget){
        if(day==1) return 1; //base case
        int result=0;
        for(int prev=day-forget+1; prev<=day-delay; prev++){
            if(prev>0) result=(result+solve(prev, delay, forget))%M;
        }
        return result;
    }
    int peopleAwareOfSecret(int n, int delay, int forget) {
        int total=0;
        for(int day=n-forget+1; day<=n; day++){
            if(day>0) total=(total+solve(day, delay, forget))%M;
        }
        return total;
    }
};

Step-2: Memosisation
class Solution {
public:
    int M=1e9+7;
    vector<int>t;
    //this will return total number of people who know secret on day "day"
    int solve(int day, int delay, int forget){
        if(day==1) return 1; //base case
        if(t[day]!=-1) return t[day];
        int result=0;
        for(int prev=day-forget+1; prev<=day-delay; prev++){
            if(prev>0) result=(result+solve(prev, delay, forget))%M;
        }
        return t[day]=result;
    }
    int peopleAwareOfSecret(int n, int delay, int forget) {
        int total=0;
        t.assign(n+1,-1);
        for(int day=n-forget+1; day<=n; day++){
            if(day>0) total=(total+solve(day, delay, forget))%M;
        }
        return total;
    }
};

//IInd Method=Bottom Up=T.C=O(n*(forget-delay))+O(n), s.c=O(n)
state Definition->t[day]=no. of people who will know the secret on "day"
class Solution {
public:
    int M=1e9+7;
    int peopleAwareOfSecret(int n, int delay, int forget) {
        vector<int>t(n+1);
        t[1]=1;
        for(int day=2; day<=n; day++){
            long long count=0;
            for(int prev=day-forget+1; prev<=day-delay; prev++){
                if(prev>0) count=(count+t[prev])%M;
            }
            t[day]=count;
        }
        int result=0;
        for(int day=n-forget+1; day<=n; day++){
            if(day>0) result=(result+t[day])%M;
        }
        return result;
    }
};*/
//Optimized Bottom up
class Solution {
public:
    int M=1e9+7;
    int peopleAwareOfSecret(int n, int delay, int forget) {
        vector<int>t(n+1);
        t[1]=1;
        int count=0; //window sum of range [day-forget+1 to day-delay]
        for(int day=2; day<=n; day++){
            if(day-delay>0) count=(count+t[day-delay])%M;
            if(day-forget>0) count=(count-t[day-forget]+M)%M; //(a-b)MOD M=(a-b+M)%M
            t[day]=count;
        }
        int result=0;
        for(int day=n-forget+1; day<=n; day++){
            if(day>0) result=(result+t[day])%M;
        }
        return result;
    }
};

